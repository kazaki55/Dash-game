import React, { useEffect, useRef, useState } from 'react';

// Dungeon Drift — single-file roguelike demo (React + Canvas)
// Features:
// - Procedural dungeon generation (random walk + rooms)
// - Turn-based movement (arrow keys / WASD)
// - Enemies that chase the player (simple pathing)
// - Items (potions, weapons, armor) and inventory (use with I)
// - XP, leveling, stat increases
// - Permadeath with high score (depth reached) persisted to localStorage
// - Small UI + keyboard controls

export default function DungeonDrift(){
  const canvasRef = useRef(null);
  const [seed, setSeed] = useState(() => Math.floor(Math.random()*1e9));
  const rngRef = useRef(() => Math.random());
  const mapRef = useRef(null);
  const stateRef = useRef(null);
  const [msg, setMsg] = useState('Welcome to Dungeon Drift — press Arrow keys or WASD to move. Press I to open inventory.');
  const [turn, setTurn] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [depth, setDepth] = useState(1);
  const [bestDepth, setBestDepth] = useState(() => Number(localStorage.getItem('dd_best')) || 1);

  // Simple seeded RNG (mulberry32)
  function setSeeded(s){ let t = s >>> 0; rngRef.current = () => { t += 0x6D2B79F5; let r = Math.imul(t ^ t>>>15, 1 | t); r ^= r + Math.imul(r ^ r>>>7, 61 | r); return ((r ^ r>>>14) >>> 0) / 4294967296; }; }
  useEffect(()=>{ setSeeded(seed); newRun(); /* eslint-disable-next-line react-hooks/exhaustive-deps */ }, [seed]);

  // Map generation: grid with random rooms + drunkard carve tunnels
  function generateMap(w = 45, h = 31){
    const rng = rngRef.current;
    const map = new Array(h).fill(0).map(()=>new Array(w).fill('#'));

    // carve a few random rectangular rooms
    const roomCount = 6 + Math.floor(rng()*6);
    const rooms = [];
    for (let r=0;r<roomCount;r++){
      const rw = 4 + Math.floor(rng()*8);
      const rh = 3 + Math.floor(rng()*6);
      const rx = 2 + Math.floor(rng()*(w-rw-4));
      const ry = 2 + Math.floor(rng()*(h-rh-4));
      for(let y=ry;y<ry+rh;y++) for(let x=rx;x<rx+rw;x++) map[y][x] = '.';
      rooms.push({x:rx,y:ry,w:rw,h:rh});
    }

    // connect rooms with drunkard walker
    function carveLine(ax,ay,bx,by){ let x=ax,y=ay; while(x!==bx||y!==by){ map[y][x]='.'; if (rng()<0.5) x += Math.sign(bx-x); else y += Math.sign(by-y); } map[by][bx]='.'; }
    for (let i=1;i<rooms.length;i++){ const a = rooms[i-1]; const b = rooms[i]; const ax = a.x + Math.floor(a.w/2); const ay = a.y + Math.floor(a.h/2); const bx = b.x + Math.floor(b.w/2); const by = b.y + Math.floor(b.h/2); carveLine(ax,ay,bx,by); }

    // fill with sparse tunnels
    let walkers = 800 + Math.floor(rng()*300);
    let cx = Math.floor(w/2), cy = Math.floor(h/2);
    while(walkers-- > 0){ map[cy][cx]='.'; const d = Math.floor(rng()*4); if (d===0) cx = Math.min(w-2, cx+1); if (d===1) cx = Math.max(1, cx-1); if (d===2) cy = Math.min(h-2, cy+1); if (d===3) cy = Math.max(1, cy-1); }

    // make border walls
    for(let y=0;y<h;y++){ map[y][0]='#'; map[y][w-1]='#'; }
    for(let x=0;x<w;x++){ map[0][x]='#'; map[h-1][x]='#'; }

    return { map, w, h, rooms };
  }

  // New run or new floor
  function newRun(){
    setGameOver(false);
    setDepth(1);
    setMsg('Descend the dungeon. Use I to manage inventory.');
    const M = generateMap();
    mapRef.current = M;
    // initial state
    const rng = rngRef.current;
    const spawnRoom = M.rooms[Math.floor(rng()*M.rooms.length)];
    const px = spawnRoom.x + Math.floor(spawnRoom.w/2);
    const py = spawnRoom.y + Math.floor(spawnRoom.h/2);
    const player = { x: px, y: py, hp: 10, maxHp: 10, atk: 3, def: 0, xp: 0, lvl: 1 };

    const enemies = [];
    // place some enemies
    const enemyCount = 6 + Math.floor(rng()*6);
    for(let i=0;i<enemyCount;i++){
      const r = M.rooms[Math.floor(rng()*M.rooms.length)];
      const ex = r.x + Math.floor(r.w * rng());
      const ey = r.y + Math.floor(r.h * rng());
      if (M.map[ey][ex] === '.' && (ex!==px || ey!==py)) enemies.push({ x: ex, y: ey, hp: 4 + Math.floor(rng()*4), atk: 2, def: 0, id: i });
    }

    const items = [];
    const itemTypes = ['potion','sword','leather','ring'];
    for(let i=0;i<8;i++){ const r = M.rooms[Math.floor(rng()*M.rooms.length)]; const ix = r.x + Math.floor(r.w * rng()); const iy = r.y + Math.floor(r.h * rng()); if (M.map[iy][ix] === '.' && (ix!==px || iy!==py)) items.push({x:ix,y:iy,type:itemTypes[Math.floor(rng()*itemTypes.length)],id:i}); }

    // stairs down
    const stairRoom = M.rooms[M.rooms.length-1];
    const stairs = { x: stairRoom.x + Math.floor(stairRoom.w/2), y: stairRoom.y + Math.floor(stairRoom.h/2) };

    stateRef.current = { player, enemies, items, stairs, messages: [], seed, rng: rngRef.current, map: M.map, w: M.w, h: M.h };
    draw();
  }

  // Draw map to canvas
  function draw(){
    const s = stateRef.current; if (!s) return; const canvas = canvasRef.current; if (!canvas) return;
    const ctx = canvas.getContext('2d'); const tile = 18; const vw = s.w * tile; const vh = s.h * tile; canvas.width = vw; canvas.height = vh; canvas.style.width = vw + 'px'; canvas.style.height = vh + 'px';

    // background
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,vw,vh);

    // tiles
    for(let y=0;y<s.h;y++) for(let x=0;x<s.w;x++){
      const ch = s.map[y][x]; const px = x*tile, py = y*tile;
      if (ch === '#'){ ctx.fillStyle = '#253341'; ctx.fillRect(px,py,tile,tile); }
      else { ctx.fillStyle = '#07132a'; ctx.fillRect(px,py,tile,tile); }
    }

    // items
    s.items.forEach(it => {
      ctx.fillStyle = it.type === 'potion' ? '#f97316' : it.type === 'sword' ? '#94a3b8' : it.type === 'leather' ? '#f59e0b' : '#60a5fa';
      ctx.fillRect(it.x*tile + 4, it.y*tile + 4, tile-8, tile-8);
    });

    // stairs
    ctx.fillStyle = '#c084fc'; ctx.fillRect(s.stairs.x*tile + 2, s.stairs.y*tile + 2, tile-4, tile-4);

    // enemies
    s.enemies.forEach(e => { ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(e.x*tile+tile/2, e.y*tile+tile/2, tile/2-2,0,Math.PI*2); ctx.fill(); });

    // player
    const p = s.player; ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(p.x*tile+tile/2, p.y*tile+tile/2, tile/2-2,0,Math.PI*2); ctx.fill();

    // HUD
    ctx.fillStyle = '#e6eef8'; ctx.font = '14px ui-sans-serif'; ctx.fillText(`Depth: ${depth}  HP: ${p.hp}/${p.maxHp}  ATK:${p.atk} DEF:${p.def}  LVL:${p.lvl} XP:${p.xp}`, 8, 14);
    ctx.fillText(`Best Depth: ${bestDepth}`, 8, 30);

    // messages
    const msgs = stateRef.current.messages.slice(-4);
    ctx.fillStyle = '#fff'; ctx.font = '12px ui-sans-serif'; for(let i=0;i<msgs.length;i++){ ctx.fillText(msgs[i], 8, s.h*tile - 8 - (msgs.length-i-1)*14); }
  }

  // Player turn processing
  function playerMove(dx, dy){ if (gameOver) return; const s = stateRef.current; const nx = s.player.x + dx; const ny = s.player.y + dy; if (nx <0 || nx>=s.w || ny<0 || ny>=s.h) return; const tile = s.map[ny][nx]; if (tile === '#'){ pushMsg('You bump into a wall.'); return; }
    // check for enemy
    const enIndex = s.enemies.findIndex(e => e.x === nx && e.y === ny);
    if (enIndex >= 0){ attackEnemy(enIndex); return; }
    // move to tile
    s.player.x = nx; s.player.y = ny; // pickup
    const itemIndex = s.items.findIndex(it => it.x === nx && it.y === ny);
    if (itemIndex >= 0){ const it = s.items[itemIndex]; pickUpItem(it); s.items.splice(itemIndex,1); }
    // stairs
    if (s.stairs.x === nx && s.stairs.y === ny){ descendFloor(); }
    // after player move, enemies act
    setTurn(t => t+1);
    enemyTurn(); draw(); }

  function attackEnemy(index){ const s = stateRef.current; const e = s.enemies[index]; const dmg = Math.max(1, s.player.atk - e.def);
    e.hp -= dmg; pushMsg(`You hit the ${e.type||'enemy'} for ${dmg}.`);
    if (e.hp <= 0){ pushMsg('Enemy dies.'); // award xp
      s.player.xp += 4; s.enemies.splice(index,1); checkLevel();
    }
    // enemy retaliates if alive
    else { const edmg = Math.max(1, e.atk - s.player.def); s.player.hp -= edmg; pushMsg(`Enemy strikes back for ${edmg}.`); if (s.player.hp <= 0) playerDies(); }
    setTurn(t => t+1);
    enemyTurn(); draw(); }

  function pickUpItem(item){ const s = stateRef.current; if (item.type === 'potion'){ s.player.hp = Math.min(s.player.maxHp, s.player.hp + 6); pushMsg('You drink a potion and heal.'); }
    else if (item.type === 'sword'){ s.player.atk += 1; pushMsg('You equip a sword. ATK increased.'); }
    else if (item.type === 'leather'){ s.player.def += 1; pushMsg('You wear leather armor. DEF increased.'); }
    else if (item.type === 'ring'){ s.player.maxHp += 2; s.player.hp += 2; pushMsg('A strange ring bolsters your vitality.'); }
  }

  function enemyTurn(){ const s = stateRef.current; // simple chase: move 1 step toward player if distance < 10
    for(let i=0;i<s.enemies.length;i++){ const e = s.enemies[i]; const dx = stateRef.current.player.x - e.x; const dy = stateRef.current.player.y - e.y; const dist = Math.abs(dx) + Math.abs(dy);
      if (dist <= 12){ // attempt to move closer
        const mov = Math.abs(dx) > Math.abs(dy) ? (dx>0? [1,0] : [-1,0]) : (dy>0? [0,1] : [0,-1]);
        const nx = e.x + mov[0], ny = e.y + mov[1]; if (nx === stateRef.current.player.x && ny === stateRef.current.player.y){ // attack
          const dmg = Math.max(1, e.atk - stateRef.current.player.def); stateRef.current.player.hp -= dmg; pushMsg(`Enemy hits you for ${dmg}.`); if (stateRef.current.player.hp <= 0) playerDies(); }
        else if (stateRef.current.map[ny][nx] === '.' && !stateRef.current.enemies.some(en=>en.x===nx && en.y===ny)) { e.x = nx; e.y = ny; }
      } else {
        // random wander
        if (Math.random() < 0.05){ const dirs = [[1,0],[-1,0],[0,1],[0,-1]]; const r = dirs[Math.floor(Math.random()*4)]; const nx = e.x + r[0], ny = e.y + r[1]; if (stateRef.current.map[ny][nx] === '.' && !stateRef.current.enemies.some(en=>en.x===nx && en.y===ny)) { e.x = nx; e.y = ny; } }
      }
    }
  }

  function checkLevel(){ const s = stateRef.current; const needed = s.player.lvl * 6; if (s.player.xp >= needed){ s.player.xp -= needed; s.player.lvl += 1; s.player.maxHp += 2; s.player.atk += 1; s.player.hp = s.player.maxHp; pushMsg(`You reach level ${s.player.lvl}! Stats improved.`); } }

  function playerDies(){ pushMsg('You died...'); setGameOver(true); if (depth > bestDepth){ setBestDepth(depth); localStorage.setItem('dd_best', String(depth)); } }

  function descendFloor(){ pushMsg('You descend deeper...'); setDepth(d => d+1); // regenerate map with same player xp/level
    // keep player stats, but heal a bit
    const prev = stateRef.current.player; const saved = { lvl: prev.lvl, xp: prev.xp, atk: prev.atk, def: prev.def, maxHp: prev.maxHp, hp: Math.min(prev.maxHp, prev.hp + Math.floor(prev.maxHp*0.4)) };
    // new seed tweak
    const newSeed = (seed + Math.floor(Math.random()*9999)) >>> 0; setSeed(newSeed);
    // after setSeed triggers newRun, we must restore player with saved state — so use timeout
    setTimeout(()=>{ const s = stateRef.current; if (!s) return; s.player.lvl = saved.lvl; s.player.xp = saved.xp; s.player.atk = saved.atk; s.player.def = saved.def; s.player.maxHp = saved.maxHp; s.player.hp = saved.hp; draw(); }, 60);
  }

  function pushMsg(t){ const s = stateRef.current; if (!s) return; s.messages.push(t); if (s.messages.length > 12) s.messages.shift(); setMsg(t); }

  // Keyboard controls
  useEffect(()=>{
    const onKey = (e) => {
      if (['ArrowUp','KeyW'].includes(e.code)){ playerMove(0,-1); }
      if (['ArrowDown','KeyS'].includes(e.code)){ playerMove(0,1); }
      if (['ArrowLeft','KeyA'].includes(e.code)){ playerMove(-1,0); }
      if (['ArrowRight','KeyD'].includes(e.code)){ playerMove(1,0); }
      if (e.code === 'KeyI'){ // inventory quick display: list items nearby and stats
        const s = stateRef.current; const itemsHere = s.items.filter(it => Math.abs(it.x - s.player.x) + Math.abs(it.y - s.player.y) <= 3);
        if (itemsHere.length === 0) pushMsg('No items nearby.'); else pushMsg('Nearby items: ' + itemsHere.map(it=>it.type).join(', '));
      }
      if (e.code === 'KeyR'){ // restart
        setSeed(Math.floor(Math.random()*1e9)); setBestDepth(b=>b); newRun(); }
      if (e.code === 'KeyG'){ // pick up everything on tile
        const s = stateRef.current; const idx = s.items.findIndex(it => it.x === s.player.x && it.y === s.player.y); if (idx >= 0){ pickUpItem(s.items[idx]); s.items.splice(idx,1); draw(); } else pushMsg('Nothing to pick up here.'); }
    };
    window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameOver, depth]);

  // initial draw
  useEffect(()=>{ draw(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [turn, msg, gameOver]);

  // small responsive container
  return (
    <div className='w-full min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center p-4 select-none'>
      <div className='w-full max-w-3xl flex items-center justify-between mb-2'>
        <h1 className='text-xl font-bold'>Dungeon Drift</h1>
        <div className='flex items-center gap-2'>
          <button onClick={()=>{ setSeed(Math.floor(Math.random()*1e9)); }} className='px-3 py-1 rounded bg-slate-800'>New Seed</button>
          <button onClick={()=>{ newRun(); }} className='px-3 py-1 rounded bg-emerald-700'>Restart Run</button>
        </div>
      </div>

      <div className='bg-black/60 p-2 rounded shadow-lg'>
        <canvas ref={canvasRef} className='rounded' />
      </div>

      <div className='mt-3 text-sm max-w-3xl text-center'>
        {msg}
        <div className='mt-2 text-xs opacity-80'>Controls: Arrow keys / WASD to move, G pick up, I inspect nearby, R restart. Descend stairs to go deeper. Permadeath is on.</div>
      </div>

      {gameOver && (
        <div className='mt-3 p-3 bg-rose-900/80 rounded'>
          <div className='font-bold text-lg'>You died</div>
          <div>Depth reached: {depth}</div>
          <div>Best depth: {bestDepth}</div>
          <button onClick={()=>{ setSeed(Math.floor(Math.random()*1e9)); newRun(); setGameOver(false); }} className='mt-2 px-3 py-1 bg-slate-800 rounded'>Try Again</button>
        </div>
      )}

    </div>
  );
}
