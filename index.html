import React, { useEffect, useRef, useState, useMemo } from "react";

// === Hyper Dash Runner — single-file React game (Canvas) ===
// Controls:
//  - Desktop: Space/Up = jump, Double-jump in air; Shift/X = dash; P = pause; R = restart
//  - Mobile: On-screen Jump/Dash buttons
// Goal: survive, collect orbs, chain dashes, buy upgrades between runs.
// This is intentionally single-file for easy copy/paste and preview.

export default function Game() {
  const canvasRef = useRef(null);
  const rafRef = useRef();
  const lastTsRef = useRef(0);
  const [paused, setPaused] = useState(false);
  const [dead, setDead] = useState(false);
  const [score, setScore] = useState(0);
  const [high, setHigh] = useState(() => Number(localStorage.getItem("hdr_high")) || 0);
  const [orbs, setOrbs] = useState(() => Number(localStorage.getItem("hdr_orbs")) || 0);
  const [shopOpen, setShopOpen] = useState(false);
  const [seed, setSeed] = useState(() => Math.floor(Math.random()*1e9));

  // Upgrades stored locally
  const [upgrades, setUpgrades] = useState(() => {
    const saved = localStorage.getItem("hdr_upgrades");
    return saved ? JSON.parse(saved) : { maxJumps: 2, dashCount: 1, magnet: 0, shield: 0, boost: 0 };
  });

  const keys = useRef({});

  // PRNG — deterministic per run
  function rngFactory(seed) {
    let s = seed >>> 0;
    return () => {
      // Xorshift32
      s ^= s << 13; s ^= s >>> 17; s ^= s << 5; s >>>= 0; 
      return s / 4294967296;
    };
  }

  // World state
  const worldRef = useRef();

  const resetWorld = () => {
    const rand = rngFactory(seed);
    worldRef.current = {
      t: 0,
      speed: 300, // px/s base
      baseSpeed: 300,
      gravity: 2000,
      scroll: 0,
      groundY: 300,
      lanes: [0],
      // entities
      player: {
        x: 120,
        y: 0,
        vx: 0,
        vy: 0,
        w: 38,
        h: 48,
        jumps: 0,
        maxJumps: upgrades.maxJumps,
        dashesLeft: upgrades.dashCount,
        invuln: 0,
        shield: 0,
        dashCD: 0,
        trail: [],
      },
      obstacles: [],
      enemies: [],
      pickups: [],
      particles: [],
      // difficulty
      timeToNextSpawn: 0.3,
      nextSpawn: 0.3,
      rand,
      dist: 0,
    };
    // ground parallax layers
    worldRef.current.layers = [
      { k: 0.2, c: "#0c0f1a" },
      { k: 0.5, c: "#11162a" },
      { k: 1,   c: "#141b34" },
    ];

    // player start height
    worldRef.current.player.y = worldRef.current.groundY - worldRef.current.player.h;
  };

  // Helpers
  function rectsIntersect(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnStuff(w) {
    const r = w.rand();
    const laneY = w.groundY;
    const farX = 900;

    // Weighted choice: obstacle, enemy, pickups cluster
    const pick = r;
    if (pick < 0.45) {
      // obstacle: box or spike
      const type = r < 0.5 ? "box" : "spike";
      const size = 30 + Math.floor(w.rand()*30);
      w.obstacles.push({ x: farX, y: laneY - size, w: size, h: size, type, col: type === "spike" ? "#d97706" : "#475569" });
    } else if (pick < 0.75) {
      // enemy: hovering drone
      const h = 26, wdt = 36;
      const y = laneY - (80 + Math.floor(w.rand()*120));
      const bob = 20 + 20*w.rand();
      w.enemies.push({ x: farX, y, w: wdt, h, bob, t: 0, type: "drone", col: "#ef4444" });
    } else {
      // pickups cluster
      const count = 3 + Math.floor(w.rand()*5);
      for (let i=0;i<count;i++) {
        const oy =  - (20 + Math.floor(w.rand()*140));
        w.pickups.push({ x: farX + i*40, y: laneY + oy, w: 18, h: 18, type: "orb", col: "#22d3ee"});
      }
    }

    // Powerup occasionally
    if (w.rand() < 0.12) {
      const types = ["magnet","shield","boost"];
      const t = types[Math.floor(w.rand()*types.length)];
      w.pickups.push({ x: farX + 40 + w.rand()*120, y: laneY - 150 - w.rand()*80, w: 20, h: 20, type: t, col: t === "shield" ? "#a3e635" : t === "magnet" ? "#f59e0b" : "#60a5fa" });
    }
  }

  function emit(w, x, y, n, c) {
    for (let i=0;i<n;i++) {
      w.particles.push({ x, y, vx: (w.rand()-0.5)*200, vy: -100 - w.rand()*200, life: 0.5 + w.rand()*0.7, t:0, c });
    }
  }

  // Input
  useEffect(() => {
    const down = (e) => { keys.current[e.code] = true; if (e.code === "Space" || e.code === "ArrowUp") e.preventDefault(); };
    const up = (e) => { keys.current[e.code] = false; };
    window.addEventListener("keydown", down);
    window.addEventListener("keyup", up);
    return () => { window.removeEventListener("keydown", down); window.removeEventListener("keyup", up); };
  }, []);

  // Game loop
  useEffect(() => {
    resetWorld();
    setScore(0);
    setDead(false);

    const loop = (ts) => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const w = worldRef.current;

      if (!lastTsRef.current) lastTsRef.current = ts;
      let dt = (ts - lastTsRef.current) / 1000; // seconds
      if (dt > 0.05) dt = 0.05; // clamp
      lastTsRef.current = ts;

      if (!paused && !dead) update(w, dt);
      render(ctx, w);

      rafRef.current = requestAnimationFrame(loop);
    };
    rafRef.current = requestAnimationFrame(loop);

    return () => cancelAnimationFrame(rafRef.current);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [seed, paused]);

  function update(w, dt) {
    w.t += dt;
    w.dist += w.speed * dt;
    // incremental difficulty
    w.baseSpeed += dt * 5; // gentle ramp
    w.speed = w.baseSpeed + (upgrades.boost ? 80 : 0);
    w.scroll += w.speed * dt;

    const p = w.player;

    // Player physics
    p.vy += w.gravity * dt;
    p.y += p.vy * dt;
    if (p.y > w.groundY - p.h) { p.y = w.groundY - p.h; p.vy = 0; p.jumps = 0; }

    // Inputs
    const wantJump = keys.current["Space"] || keys.current["ArrowUp"];
    const wantDash = keys.current["ShiftLeft"] || keys.current["KeyX"];

    p.dashCD = Math.max(0, p.dashCD - dt);
    p.invuln = Math.max(0, p.invuln - dt);
    p.shield = Math.max(0, p.shield - dt);

    // Jump (press edge)
    if (wantJump && !p._jumpHeld) {
      if (p.jumps < p.maxJumps) {
        p.vy = -750;
        p.jumps++;
        emit(w, p.x+p.w/2, p.y+p.h, 10, "#22d3ee");
      }
    }
    p._jumpHeld = wantJump;

    // Dash
    if (wantDash && !p._dashHeld && p.dashesLeft > 0 && p.dashCD === 0) {
      p.dashesLeft--; p.dashCD = 0.35; p.invuln = Math.max(p.invuln, 0.2);
      // Add forward burst by temporarily increasing world scroll feel via trail
      p.trail.push({ life: 0.2, x: p.x, y: p.y, w: p.w, h: p.h });
      emit(w, p.x+p.w, p.y+p.h/2, 16, "#60a5fa");
    }
    p._dashHeld = wantDash;

    // Refill dash on ground
    if (p.y >= w.groundY - p.h - 0.001) {
      p.dashesLeft = upgrades.dashCount;
    }

    // Parallax layers update (implicit via scroll)

    // Spawn logic
    w.timeToNextSpawn -= dt;
    if (w.timeToNextSpawn <= 0) {
      spawnStuff(w);
      const base = 0.7;
      const accel = Math.max(0.25, 1.2 - w.t * 0.02);
      w.timeToNextSpawn = base * accel;
    }

    const left = -100;

    // Move entities left according to speed
    const move = (e) => { e.x -= w.speed * dt; };
    w.obstacles.forEach(move);
    w.enemies.forEach((e) => { e.x -= w.speed * dt; e.t += dt; e.y += Math.sin((w.t+e.t)*2) * (e.bob*dt);});

    // Pickups attraction (magnet)
    const magnetRange = 80 + upgrades.magnet*40;
    w.pickups.forEach((c) => {
      c.x -= w.speed * dt;
      if (c.type === "orb" && magnetRange > 0) {
        const cx = c.x + c.w/2, cy = c.y + c.h/2;
        const px = p.x + p.w/2, py = p.y + p.h/2;
        const dx = px - cx, dy = py - cy;
        const d2 = dx*dx + dy*dy;
        const r2 = magnetRange*magnetRange;
        if (d2 < r2) {
          const d = Math.max(0.001, Math.sqrt(d2));
          const k = 600 * (1 - d/Math.sqrt(r2));
          c.x += (dx/d) * k * dt;
          c.y += (dy/d) * k * dt;
        }
      }
    });

    // Trails & particles
    p.trail.forEach(t => t.life -= dt);
    p.trail = p.trail.filter(t => t.life > 0);

    w.particles.forEach(pt => { pt.t += dt; pt.x += pt.vx*dt; pt.y += pt.vy*dt; });
    w.particles = w.particles.filter(pt => pt.t < pt.life);

    // Collisions
    // Player hurt only if not invulnerable; shield can absorb
    const pRect = { x: p.x, y: p.y, w: p.w, h: p.h };

    // Pickups first
    let gained = 0;
    w.pickups = w.pickups.filter(c => {
      const hit = rectsIntersect(pRect, c);
      if (hit) {
        if (c.type === "orb") { gained++; emit(w, c.x, c.y, 6, "#22d3ee"); return false; }
        if (c.type === "shield") { p.shield = Math.min(3, p.shield + 2 + upgrades.shield); emit(w, p.x, p.y, 12, "#a3e635"); return false; }
        if (c.type === "magnet") { /* passive via upgrade */ emit(w, p.x, p.y, 10, "#f59e0b"); w.baseSpeed += 0; return false; }
        if (c.type === "boost") { emit(w, p.x, p.y, 10, "#60a5fa"); w.baseSpeed += 40; return false; }
      }
      return c.x + c.w > left;
    });
    if (gained) setScore(s => s + gained*10);

    const hitSomething = (arr) => {
      for (let i=0;i<arr.length;i++) {
        const e = arr[i];
        if (rectsIntersect(pRect, e)) {
          // absorb with shield, else die (unless invuln)
          if (p.invuln > 0) { emit(w, e.x, e.y, 8, "#60a5fa"); arr.splice(i,1); return false; }
          if (p.shield > 0) { p.shield = Math.max(0, p.shield - 1); emit(w, e.x, e.y, 12, "#a3e635"); arr.splice(i,1); return false; }
          return true;
        }
      }
      return false;
    };

    if (hitSomething(w.obstacles) || hitSomething(w.enemies)) {
      setDead(true);
      setHigh(h => { const nh = Math.max(h, score); localStorage.setItem("hdr_high", nh.toString()); return nh; });
      setOrbs(o => { const no = o + Math.floor(score/10); localStorage.setItem("hdr_orbs", no.toString()); return no; });
    }

    // Cleanup off-screen
    w.obstacles = w.obstacles.filter(o => o.x + o.w > left);
    w.enemies   = w.enemies.filter(e => e.x + e.w > left);
    w.pickups   = w.pickups.filter(c => c.x + c.w > left);
  }

  function render(ctx, w) {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const vw = Math.min(900, Math.floor(window.innerWidth));
    const vh = Math.min(520, Math.floor(window.innerHeight*0.75));
    const cw = vw * dpr, ch = vh * dpr;

    const canvas = ctx.canvas;
    if (canvas.width !== cw || canvas.height !== ch) {
      canvas.width = cw; canvas.height = ch; canvas.style.width = vw+"px"; canvas.style.height = vh+"px";
    }

    // world units = pixels at dpr scale
    ctx.save();
    ctx.scale(dpr, dpr);

    // Sky gradient
    const g = ctx.createLinearGradient(0,0,0,vh);
    g.addColorStop(0, "#0b1020");
    g.addColorStop(1, "#0b132b");
    ctx.fillStyle = g; ctx.fillRect(0,0,vw,vh);

    // Stars
    ctx.globalAlpha = 0.6;
    for (let i=0;i<60;i++) {
      const x = (i*73 + (w.scroll*0.02)) % (vw+40) - 20;
      const y = (i*53 % (vh*0.6));
      ctx.fillStyle = i%5===0?"#e5e7eb":"#9ca3af";
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // Parallax city silhouettes
    w.layers.forEach((L, idx) => {
      ctx.fillStyle = L.c;
      const h = 120 + idx*30;
      const baseY = vh - h - 60;
      const step = 80;
      const offset = - (w.scroll * L.k) % (step*2);
      for (let x = -step*2; x < vw + step*2; x += step) {
        const bw = step - 10 + (idx*10);
        const bh = h + ((x/step)%3)*15;
        ctx.fillRect(x + offset, baseY - bh, bw, bh);
      }
    });

    // Ground
    ctx.fillStyle = "#0f172a";
    ctx.fillRect(0, w.groundY + 20, vw, vh - (w.groundY+20));
    // Rail
    ctx.fillStyle = "#1e293b";
    ctx.fillRect(0, w.groundY, vw, 6);
    for (let i=0;i<vw;i+=24){ ctx.fillRect((i - (w.scroll%24)), w.groundY+6, 12, 3); }

    // Pickups
    w.pickups.forEach(c => {
      ctx.fillStyle = c.col;
      ctx.beginPath();
      ctx.roundRect(Math.floor(c.x), Math.floor(c.y), c.w, c.h, 4);
      ctx.fill();
    });

    // Obstacles
    w.obstacles.forEach(o => {
      ctx.fillStyle = o.col;
      if (o.type === "spike") {
        const spikes = Math.max(2, Math.floor(o.w/10));
        for (let i=0;i<spikes;i++) {
          const x = o.x + i*(o.w/spikes);
          ctx.beginPath();
          ctx.moveTo(x, o.y+o.h);
          ctx.lineTo(x + o.w/spikes/2, o.y);
          ctx.lineTo(x + o.w/spikes, o.y+o.h);
          ctx.closePath(); ctx.fill();
        }
      } else {
        ctx.fillRect(Math.floor(o.x), Math.floor(o.y), o.w, o.h);
      }
    });

    // Enemies (drones)
    w.enemies.forEach(e => {
      ctx.fillStyle = e.col;
      ctx.fillRect(Math.floor(e.x), Math.floor(e.y), e.w, e.h);
      // eye
      ctx.fillStyle = "#fee2e2";
      ctx.fillRect(Math.floor(e.x+e.w-10), Math.floor(e.y+6), 4, 4);
      // legs
      ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(e.x+4, e.y+e.h);
      ctx.lineTo(e.x+4, e.y+e.h+6);
      ctx.moveTo(e.x+e.w-4, e.y+e.h);
      ctx.lineTo(e.x+e.w-4, e.y+e.h+6);
      ctx.stroke();
    });

    // Player
    const p = w.player;
    // Shadow
    ctx.globalAlpha = 0.2; ctx.fillStyle = "black"; ctx.beginPath(); ctx.ellipse(p.x+p.w/2, w.groundY+10, 18, 6, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;

    // Trail (dash)
    p.trail.forEach(t => {
      ctx.globalAlpha = Math.max(0, t.life*4);
      ctx.fillStyle = "#60a5fa";
      ctx.fillRect(Math.floor(t.x), Math.floor(t.y), t.w, t.h);
    });
    ctx.globalAlpha = 1;

    // Body
    ctx.fillStyle = "#93c5fd";
    ctx.fillRect(Math.floor(p.x), Math.floor(p.y), p.w, p.h);
    // visor
    ctx.fillStyle = "#1d4ed8"; ctx.fillRect(p.x+6, p.y+10, p.w-12, 10);

    // Shield halo
    if (p.shield > 0) {
      ctx.strokeStyle = "#a3e635"; ctx.lineWidth = 3; ctx.globalAlpha = 0.6 + 0.4*Math.sin(w.t*8);
      ctx.beginPath(); ctx.roundRect(p.x-4, p.y-4, p.w+8, p.h+8, 8); ctx.stroke(); ctx.globalAlpha = 1;
    }

    // Particles
    w.particles.forEach(pt => {
      ctx.globalAlpha = Math.max(0, 1 - pt.t/pt.life);
      ctx.fillStyle = pt.c;
      ctx.fillRect(Math.floor(pt.x), Math.floor(pt.y), 3, 3);
    });
    ctx.globalAlpha = 1;

    // HUD
    ctx.fillStyle = "#e2e8f0"; ctx.font = "16px ui-sans-serif,system-ui";
    ctx.fillText(`Score: ${score}`, 12, 22);
    ctx.fillText(`Best: ${high}`, 12, 42);
    ctx.fillText(`Orbs: ${orbs}`, 12, 62);
    ctx.fillText(`Jumps: ${w.player.maxJumps}  Dash: ${w.player.dashesLeft}/${upgrades.dashCount}`, 12, 82);

    if (dead) {
      ctx.fillStyle = "#e2e8f0"; ctx.font = "bold 28px ui-sans-serif,system-ui";
      const text = "Game Over";
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, (vw - tw)/2, 120);
      ctx.font = "16px ui-sans-serif,system-ui";
      ctx.fillText("Tap or press R to try again", vw/2 - 120, 160);
    }

    ctx.restore();
  }

  // Restart
  const restart = () => {
    setDead(false);
    setScore(0);
    setSeed(Math.floor(Math.random()*1e9));
    lastTsRef.current = 0;
  };

  // Keybinds for meta
  useEffect(() => {
    const onKey = (e) => {
      if (e.code === "KeyP") setPaused(p => !p);
      if (e.code === "KeyR") { if (dead) restart(); }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [dead]);

  // Mobile buttons handlers
  const jump = () => { keys.current["Space"] = true; setTimeout(()=>{ keys.current["Space"] = false; }, 80); };
  const dash = () => { keys.current["KeyX"] = true; setTimeout(()=>{ keys.current["KeyX"] = false; }, 60); };

  // Shop logic
  const shop = useMemo(() => ([
    { key: "maxJumps", label: "+1 Max Jump", cap: 3, base: 60 },
    { key: "dashCount", label: "+1 Dash", cap: 3, base: 80 },
    { key: "magnet", label: "Magnet Range +", cap: 3, base: 70 },
    { key: "shield", label: "Shield Capacity +", cap: 3, base: 90 },
    { key: "boost", label: "Permanent Speed Boost", cap: 1, base: 120 },
  ]), []);

  const buy = (it) => {
    const lvl = upgrades[it.key];
    if (lvl >= it.cap) return;
    const cost = Math.floor(it.base * Math.pow(1.7, lvl));
    if (orbs >= cost) {
      const nu = { ...upgrades, [it.key]: lvl+1 };
      setUpgrades(nu);
      localStorage.setItem("hdr_upgrades", JSON.stringify(nu));
      const no = orbs - cost; setOrbs(no); localStorage.setItem("hdr_orbs", no.toString());
    }
  };

  return (
    <div className="w-full min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center px-3 py-4 select-none">
      <div className="w-full max-w-3xl flex items-center justify-between gap-2 mb-2">
        <h1 className="text-xl font-bold tracking-tight">Hyper Dash Runner</h1>
        <div className="flex items-center gap-2">
          <button onClick={()=>setPaused(p=>!p)} className="px-3 py-1 rounded-2xl bg-slate-800 hover:bg-slate-700 shadow">{paused?"Resume":"Pause"}</button>
          <button onClick={()=>setShopOpen(s=>!s)} className="px-3 py-1 rounded-2xl bg-slate-800 hover:bg-slate-700 shadow">Shop</button>
          <button onClick={restart} className="px-3 py-1 rounded-2xl bg-sky-700 hover:bg-sky-600 shadow">Restart</button>
        </div>
      </div>

      <canvas ref={canvasRef} className="rounded-2xl shadow-lg border border-slate-800 bg-black" />

      <div className="mt-2 text-sm opacity-80">Jump: Space/Up • Dash: Shift/X • P: Pause • R: Restart</div>

      {/* Mobile Controls */}
      <div className="fixed bottom-4 left-0 right-0 mx-auto max-w-3xl px-4 flex items-center justify-between pointer-events-none">
        <button onTouchStart={jump} onMouseDown={jump} className="pointer-events-auto px-5 py-4 rounded-2xl bg-slate-800/70 backdrop-blur shadow active:scale-95">Jump</button>
        <button onTouchStart={dash} onMouseDown={dash} className="pointer-events-auto px-5 py-4 rounded-2xl bg-slate-800/70 backdrop-blur shadow active:scale-95">Dash</button>
      </div>

      {/* Shop Drawer */}
      {shopOpen && (
        <div className="fixed inset-0 bg-black/60 flex items-end sm:items-center justify-center p-4 z-50" onClick={()=>setShopOpen(false)}>
          <div className="w-full max-w-md bg-slate-900 rounded-2xl border border-slate-800 shadow-xl p-4" onClick={(e)=>e.stopPropagation()}>
            <div className="flex items-center justify-between mb-2">
              <h2 className="text-lg font-semibold">Runner Upgrades</h2>
              <button className="px-3 py-1 rounded-2xl bg-slate-800 hover:bg-slate-700" onClick={()=>setShopOpen(false)}>Close</button>
            </div>
            <div className="text-sm mb-3">Orbs: <span className="font-semibold">{orbs}</span></div>
            <div className="space-y-2">
              {shop.map((it)=>{
                const lvl = upgrades[it.key];
                const cost = lvl >= it.cap ? null : Math.floor(it.base * Math.pow(1.7, lvl));
                return (
                  <div key={it.key} className="flex items-center justify-between bg-slate-800/60 rounded-xl p-3">
                    <div>
                      <div className="font-medium">{it.label}</div>
                      <div className="text-xs opacity-80">Level {lvl} / {it.cap}</div>
                    </div>
                    <button disabled={lvl>=it.cap || orbs<cost} onClick={()=>buy(it)} className={`px-3 py-1 rounded-lg shadow ${lvl>=it.cap?"bg-slate-700 opacity-60":"bg-sky-700 hover:bg-sky-600"}`}>
                      {lvl>=it.cap?"Maxed":`Buy (${cost})`}
                    </button>
                  </div>
                );
              })}
            </div>
            <div className="text-xs opacity-80 mt-3">Upgrades persist between runs on this device.</div>
          </div>
        </div>
      )}

      {/* Tips */}
      <div className="mt-3 text-xs opacity-70 max-w-3xl text-center">
        Tip: chain jumps to clear drones, dash to phase through hazards briefly, and grab blue orbs for poin
